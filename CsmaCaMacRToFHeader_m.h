//
// Generated file, do not edit! Created by nedtool 5.6 from CsmaCaMacRToFHeader.msg.
//

#ifndef __INET_CSMACAMACRTOFHEADER_M_H
#define __INET_CSMACAMACRTOFHEADER_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif


namespace inet {

class CsmaCaMacRToFHeader;
class CsmaCaMacRToFAckHeader;
class CsmaCaMacRToFDataHeader;
class CsmaCaMacRToFTrailer;
class CsmaCaMacRToFBackoffHeader;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/linklayer/common/FcsMode_m.h" // import inet.linklayer.common.FcsMode

#include "inet/linklayer/common/MacAddress_m.h" // import inet.linklayer.common.MacAddress


namespace inet {

/**
 * Enum generated from <tt>CsmaCaMacRToFHeader.msg:25</tt> by nedtool.
 * <pre>
 * enum CsmaCaMacRToFHeaderType
 * {
 *     CSMA_DATA = 1;
 *     CSMA_ACK = 2;
 * }
 * </pre>
 */
enum CsmaCaMacRToFHeaderType {
    CSMA_DATA = 1,
    CSMA_ACK = 2
};

/**
 * Class generated from <tt>CsmaCaMacRToFHeader.msg:31</tt> by nedtool.
 * <pre>
 * class CsmaCaMacRToFHeader extends FieldsChunk
 * {
 *     CsmaCaMacRToFHeaderType type;    // header type (1 byte)
 *     uint8_t headerLengthField;    // header length in bytes, max value is 255 (1 byte)
 *     MacAddress transmitterAddress;    // (6 byte)
 *     MacAddress receiverAddress;    // (6 byte)
 * }
 * </pre>
 */
class CsmaCaMacRToFHeader : public ::inet::FieldsChunk
{
  protected:
    inet::CsmaCaMacRToFHeaderType type = static_cast<inet::CsmaCaMacRToFHeaderType>(-1);
    uint8_t headerLengthField = 0;
    MacAddress transmitterAddress;
    MacAddress receiverAddress;

  private:
    void copy(const CsmaCaMacRToFHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CsmaCaMacRToFHeader&);

  public:
    CsmaCaMacRToFHeader();
    CsmaCaMacRToFHeader(const CsmaCaMacRToFHeader& other);
    virtual ~CsmaCaMacRToFHeader();
    CsmaCaMacRToFHeader& operator=(const CsmaCaMacRToFHeader& other);
    virtual CsmaCaMacRToFHeader *dup() const override {return new CsmaCaMacRToFHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::CsmaCaMacRToFHeaderType getType() const;
    virtual void setType(inet::CsmaCaMacRToFHeaderType type);
    virtual uint8_t getHeaderLengthField() const;
    virtual void setHeaderLengthField(uint8_t headerLengthField);
    virtual const MacAddress& getTransmitterAddress() const;
    virtual MacAddress& getTransmitterAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<CsmaCaMacRToFHeader*>(this)->getTransmitterAddress());}
    virtual void setTransmitterAddress(const MacAddress& transmitterAddress);
    virtual const MacAddress& getReceiverAddress() const;
    virtual MacAddress& getReceiverAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<CsmaCaMacRToFHeader*>(this)->getReceiverAddress());}
    virtual void setReceiverAddress(const MacAddress& receiverAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CsmaCaMacRToFHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CsmaCaMacRToFHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>CsmaCaMacRToFHeader.msg:39</tt> by nedtool.
 * <pre>
 * class CsmaCaMacRToFAckHeader extends CsmaCaMacRToFHeader
 * {
 *     chunkLength = B(14);
 *     type = CSMA_ACK;
 * }
 * </pre>
 */
class CsmaCaMacRToFAckHeader : public ::inet::CsmaCaMacRToFHeader
{
  protected:

  private:
    void copy(const CsmaCaMacRToFAckHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CsmaCaMacRToFAckHeader&);

  public:
    CsmaCaMacRToFAckHeader();
    CsmaCaMacRToFAckHeader(const CsmaCaMacRToFAckHeader& other);
    virtual ~CsmaCaMacRToFAckHeader();
    CsmaCaMacRToFAckHeader& operator=(const CsmaCaMacRToFAckHeader& other);
    virtual CsmaCaMacRToFAckHeader *dup() const override {return new CsmaCaMacRToFAckHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CsmaCaMacRToFAckHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CsmaCaMacRToFAckHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>CsmaCaMacRToFHeader.msg:45</tt> by nedtool.
 * <pre>
 * class CsmaCaMacRToFDataHeader extends CsmaCaMacRToFHeader
 * {
 *     chunkLength = B(17);
 *     type = CSMA_DATA;
 *     int networkProtocol = -1;    // ethernet protocol ID (2 bytes)
 *     int priority = -1;    // 802.1d UP (User Priority) (1 byte)
 * }
 * </pre>
 */
class CsmaCaMacRToFDataHeader : public ::inet::CsmaCaMacRToFHeader
{
  protected:
    int networkProtocol = -1;
    int priority = -1;

  private:
    void copy(const CsmaCaMacRToFDataHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CsmaCaMacRToFDataHeader&);

  public:
    CsmaCaMacRToFDataHeader();
    CsmaCaMacRToFDataHeader(const CsmaCaMacRToFDataHeader& other);
    virtual ~CsmaCaMacRToFDataHeader();
    CsmaCaMacRToFDataHeader& operator=(const CsmaCaMacRToFDataHeader& other);
    virtual CsmaCaMacRToFDataHeader *dup() const override {return new CsmaCaMacRToFDataHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getNetworkProtocol() const;
    virtual void setNetworkProtocol(int networkProtocol);
    virtual int getPriority() const;
    virtual void setPriority(int priority);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CsmaCaMacRToFDataHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CsmaCaMacRToFDataHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>CsmaCaMacRToFHeader.msg:53</tt> by nedtool.
 * <pre>
 * class CsmaCaMacRToFTrailer extends FieldsChunk
 * {
 *     chunkLength = B(4);
 *     uint32_t fcs = 0;
 *     FcsMode fcsMode = FCS_MODE_UNDEFINED;
 * }
 * </pre>
 */
class CsmaCaMacRToFTrailer : public ::inet::FieldsChunk
{
  protected:
    uint32_t fcs = 0;
    inet::FcsMode fcsMode = FCS_MODE_UNDEFINED;

  private:
    void copy(const CsmaCaMacRToFTrailer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CsmaCaMacRToFTrailer&);

  public:
    CsmaCaMacRToFTrailer();
    CsmaCaMacRToFTrailer(const CsmaCaMacRToFTrailer& other);
    virtual ~CsmaCaMacRToFTrailer();
    CsmaCaMacRToFTrailer& operator=(const CsmaCaMacRToFTrailer& other);
    virtual CsmaCaMacRToFTrailer *dup() const override {return new CsmaCaMacRToFTrailer(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getFcs() const;
    virtual void setFcs(uint32_t fcs);
    virtual inet::FcsMode getFcsMode() const;
    virtual void setFcsMode(inet::FcsMode fcsMode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CsmaCaMacRToFTrailer& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CsmaCaMacRToFTrailer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>CsmaCaMacRToFHeader.msg:60</tt> by nedtool.
 * <pre>
 * class CsmaCaMacRToFBackoffHeader extends BytesChunk
 * {
 *     simtime_t backoffTime; // (8 bytes)
 * }
 * </pre>
 */
class CsmaCaMacRToFBackoffHeader : public ::inet::BytesChunk
{
  protected:
    omnetpp::simtime_t backoffTime = SIMTIME_ZERO;

  private:
    void copy(const CsmaCaMacRToFBackoffHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CsmaCaMacRToFBackoffHeader&);

  public:
    CsmaCaMacRToFBackoffHeader();
    CsmaCaMacRToFBackoffHeader(const CsmaCaMacRToFBackoffHeader& other);
    virtual ~CsmaCaMacRToFBackoffHeader();
    CsmaCaMacRToFBackoffHeader& operator=(const CsmaCaMacRToFBackoffHeader& other);
    virtual CsmaCaMacRToFBackoffHeader *dup() const override {return new CsmaCaMacRToFBackoffHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t getBackoffTime() const;
    virtual void setBackoffTime(omnetpp::simtime_t backoffTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CsmaCaMacRToFBackoffHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CsmaCaMacRToFBackoffHeader& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_CSMACAMACRTOFHEADER_M_H

